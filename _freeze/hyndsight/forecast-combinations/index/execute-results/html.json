{
  "hash": "4fcf9bb1eaada727af31d1f057ff2c02",
  "result": {
    "markdown": "---\ndate: 2016-09-01 09:56:16+00:00\nslug: forecast-combinations\ntitle: R packages for forecast combinations\ncategories:\n- forecasting\n- R\n---\n\n\n\n\nIt has been well-known since at least 1969, when Bates and Granger wrote their famous paper on [“The Combination of Forecasts”](https://www.jstor.org/stable/3008764), that combining forecasts often leads to better forecast accuracy.\n\nSo it is helpful to have a couple of new R packages which do just that: **opera** and **forecastHybrid**.\n\n<!-- more -->\n\n## opera\n\nOpera stands for “Online Prediction by ExpeRt Aggregation”. It was written by Pierre Gaillard and Yannig Goude, and Pierre provides a nice introduction in [the vignette](https://cran.r-project.org/web/packages/opera/vignettes/opera-vignette.html). While it can be used with combining any sort of predictions, I will just consider simple univariate time series forecasts, using the monthly `co2` data.\n\n\n::: {.cell hash='index_cache/html/opera_4f9467edeaee7bf7d5796388a3c8e709'}\n\n```{.r .cell-code}\nlibrary(forecast)\nlibrary(ggplot2)\ntrain <- window(co2, end=c(1990,12))\ntest <- window(co2, start=c(1991,1))\nh <- length(test)\nETS <- forecast(ets(train), h=h)\nARIMA <- forecast(auto.arima(train, lambda=0), h=h)\nSTL <- stlf(train, lambda=0, h=h)\nX <- cbind(ETS=ETS$mean, ARIMA=ARIMA$mean, STL=STL$mean)\ndf <- cbind(co2, X)\ncolnames(df) <- c(\"Data\",\"ETS\",\"ARIMA\",\"STL\")\nautoplot(df) +\n  xlab(\"Year\") + ylab(expression(\"Atmospheric concentration of CO\"[2]))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/opera-1.png){width=672}\n:::\n:::\n\n\nHere, ETS has done a particularly bad job at picking the trend, while the other two look ok.\n\nThe mixture function from the `opera` package computes weights when combining the forecasts based on how well it has done up to that point.\n\n\n::: {.cell hash='index_cache/html/opera2_f825bff35ff4114eda84a0e17373c88c'}\n\n```{.r .cell-code}\nlibrary(opera)\nMLpol0 <- mixture(model = \"MLpol\", loss.type = \"square\")\nweights <- predict(MLpol0, X, test, type='weights')\nhead(weights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ETS  ARIMA    STL\n[1,] 0.3333 0.3333 0.3333\n[2,] 0.5447 0.0000 0.4553\n[3,] 0.6352 0.0000 0.3648\n[4,] 0.5416 0.0000 0.4584\n[5,] 0.0000 0.0000 1.0000\n[6,] 0.0000 0.0000 1.0000\n```\n:::\n\n```{.r .cell-code}\ntail(weights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      ETS ARIMA STL\n[79,]   0     1   0\n[80,]   0     1   0\n[81,]   0     1   0\n[82,]   0     1   0\n[83,]   0     1   0\n[84,]   0     1   0\n```\n:::\n:::\n\n\n\nIt begins with weighting each forecast method equally, quickly drops the ARIMA method, and then switches to STL alone. But by the end of the test set, it is giving weight 0 to ETS, 1 to ARIMA and 0 to STL. Here are the resulting forecasts:\n\n\n::: {.cell hash='index_cache/html/opera3_9e1fec41edffca0f81a96e572854ea3e'}\n\n```{.r .cell-code}\nz <- ts(predict(MLpol0, X, test, type='response'), start=c(1991,1), freq=12)\ndf <- cbind(co2, z)\ncolnames(df) <- c(\"Data\",\"Mixture\")\nautoplot(df) +\n  xlab(\"Year\") + ylab(expression(\"Atmospheric concentration of CO\"[2]))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/opera3-1.png){width=672}\n:::\n:::\n\n\n\n## forecastHybrid\n\n\n\nThe `forecastHybrid` package from David Shaub and Peter Ellis fits multiple models from the `forecast` package and then combines them using either equal weights, or weights based on in-sample errors. By default, the models combined are from the `auto.arima`, `ets`, `nnetar`, `stlm` and `tbats` functions. David Shaub provides a [helpful vignette](https://cran.r-project.org/web/packages/forecastHybrid/vignettes/forecastHybrid.html) explaining how to use the package.\n\nHere is an example using the same `co2` data.\n\n\n::: {.cell hash='index_cache/html/forecastHybrid_3cc15596bb73f332d629963001841e55'}\n\n```{.r .cell-code}\nlibrary(forecastHybrid)\nfit1 <- hybridModel(train, weights=\"equal\")\nfit2 <- hybridModel(train, weights=\"insample\")\nfc1 <- forecast(fit1, h=h)\nfc2 <- forecast(fit2, h=h)\nautoplot(fc1) + ggtitle(\"Hybrid 1\") + xlab(\"Year\") +\n ylab(expression(\"Atmospheric concentration of CO\"[2]))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/forecastHybrid-1.png){width=672}\n:::\n:::\n\n\n\n\nThose prediction intervals look dodgy because they are way too conservative. The package is taking the widest possible intervals that includes all the intervals produced by the individual models. So you only need one bad model, and the prediction intervals are screwed. To compute prediction intervals with the required coverage, it would be necessary to estimate the covariances between the different forecast errors, and then find the resulting variance expression for the linear combination of methods.\n\nThe combination point forecasts look much better:\n\n\n::: {.cell hash='index_cache/html/forecastHybrid2_392015ef305f6fdbd3f50a6a0efd8f54'}\n\n```{.r .cell-code}\ndf <- cbind(Data=co2, Hybrid1=fc1$mean, Hybrid2=fc2$mean)\nautoplot(df) +\n  xlab(\"Year\") + ylab(expression(\"Atmospheric concentration of CO\"[2]))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/forecastHybrid2-1.png){width=672}\n:::\n:::\n\n\nNote that the weights are not being updated, unlike with the `opera` package. In this particular example, the `opera` forecasts are doing substantially better:\n\n\n::: {.cell hash='index_cache/html/forecastHybrid3_5786656e1f50a50d82f97d0cb60e686b'}\n\n```{.r .cell-code}\nmse <- c(Opera=mean((test-z)^2),\n          Hybrid1=mean((test - fc1$mean)^2),\n          Hybrid2=mean((test - fc2$mean)^2))\nround(mse,2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Opera Hybrid1 Hybrid2 \n   0.68    0.66    1.17 \n```\n:::\n:::\n\n\nIt should be noted, however, that the opera weights are updated using the past test data, while the forecastHybrid weights are based only on the training data. So this comparison is not entirely \"fair\".\n\nAlso, all of these results are much better than any of the individual forecasting methods:\n\n\n::: {.cell hash='index_cache/html/forecastHybrid4_5d13f8389d9f5165de332a52c6d269f1'}\n\n```{.r .cell-code}\nmse2 <- c(ETS=mean((test-ETS$mean)^2),\n          ARIMA=mean((test-ARIMA$mean)^2),\n          STL=mean((test-STL$mean)^2))\nround(mse2,2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ETS ARIMA   STL \n 1.34  0.68  2.04 \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}