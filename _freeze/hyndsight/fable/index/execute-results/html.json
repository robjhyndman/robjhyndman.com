{
  "hash": "dd0b76e41104f6bef8350b0b2825bf77",
  "result": {
    "markdown": "---\ndate: 2019-09-29\ntitle: \"Tidy forecasting in R\"\nslug: fable\ncategories:\n- time series\n- graphics\n- statistics\n- R\n- tidyverts\n- forecasting\nimage: index_files/figure-html/snowy-fc-plot-1.png\n---\n\n\n\n\nThe **fable** package for doing tidy forecasting in R is now on CRAN. Like **[tsibble](https://tsibble.tidyverts.org)** and **[feasts](https://feasts.tidyverts.org)**, it is also part of the [tidyverts](https://tidyverts.org) family of packages for analysing, modelling and forecasting many related time series (stored as tsibbles).\n\nFor a brief introduction to tsibbles, see [this post](https://robjhyndman.com/hyndsight/tsibbles/) from last month.\n\nHere we will forecast Australian tourism data by state/region and purpose. This data is stored in the `tourism` tsibble where `Trips` contains domestic visitor nights in thousands.\n\n\n::: {.cell hash='index_cache/html/tourismdata_846b03fd180be72f33c4b65254cfbe22'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tsibble)\nlibrary(lubridate)\nlibrary(fable)\ntourism\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 24,320 x 5 [1Q]\n# Key:       Region, State, Purpose [304]\n   Quarter Region   State           Purpose  Trips\n     <qtr> <chr>    <chr>           <chr>    <dbl>\n 1 1998 Q1 Adelaide South Australia Business  135.\n 2 1998 Q2 Adelaide South Australia Business  110.\n 3 1998 Q3 Adelaide South Australia Business  166.\n 4 1998 Q4 Adelaide South Australia Business  127.\n 5 1999 Q1 Adelaide South Australia Business  137.\n 6 1999 Q2 Adelaide South Australia Business  200.\n 7 1999 Q3 Adelaide South Australia Business  169.\n 8 1999 Q4 Adelaide South Australia Business  134.\n 9 2000 Q1 Adelaide South Australia Business  154.\n10 2000 Q2 Adelaide South Australia Business  169.\n# … with 24,310 more rows\n```\n:::\n:::\n\n\nThere are 304 combinations of Region, State and Purpose, each one defining a time series of 80 observations.\n\nTo simplify the outputs, we will abbreviate the state names.\n\n\n::: {.cell hash='index_cache/html/tourism_199f76667923c31551ccf3162ee5260c'}\n\n```{.r .cell-code}\ntourism <- tourism %>%\n  mutate(\n    State = recode(State,\n      \"Australian Capital Territory\" = \"ACT\",\n      \"New South Wales\" = \"NSW\",\n      \"Northern Territory\" = \"NT\",\n      \"Queensland\" = \"QLD\",\n      \"South Australia\" = \"SA\",\n      \"Tasmania\" = \"TAS\",\n      \"Victoria\" = \"VIC\",\n      \"Western Australia\" = \"WA\"\n    )\n  )\n```\n:::\n\n\n## Forecasting a single time series\n\nAlthough the **fable** package is designed to handle many time series, we will be begin by demonstrating its use on a single time series. For this purpose, we will extract the tourism data for holidays in the Snowy Mountains region of NSW.\n\n\n::: {.cell hash='index_cache/html/extract_6e5be2194d6a6be70aef8ac311aafc24'}\n\n```{.r .cell-code}\nsnowy <- tourism %>%\n  filter(\n    Region == \"Snowy Mountains\",\n    Purpose == \"Holiday\"\n  )\nsnowy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 80 x 5 [1Q]\n# Key:       Region, State, Purpose [1]\n   Quarter Region          State Purpose Trips\n     <qtr> <chr>           <chr> <chr>   <dbl>\n 1 1998 Q1 Snowy Mountains NSW   Holiday 101. \n 2 1998 Q2 Snowy Mountains NSW   Holiday 112. \n 3 1998 Q3 Snowy Mountains NSW   Holiday 310. \n 4 1998 Q4 Snowy Mountains NSW   Holiday  89.8\n 5 1999 Q1 Snowy Mountains NSW   Holiday 112. \n 6 1999 Q2 Snowy Mountains NSW   Holiday 103. \n 7 1999 Q3 Snowy Mountains NSW   Holiday 254. \n 8 1999 Q4 Snowy Mountains NSW   Holiday  74.9\n 9 2000 Q1 Snowy Mountains NSW   Holiday 118. \n10 2000 Q2 Snowy Mountains NSW   Holiday 114. \n# … with 70 more rows\n```\n:::\n\n```{.r .cell-code}\nsnowy %>% autoplot(Trips)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/extract-1.png){width=672}\n:::\n:::\n\n\nFor this data set, a reasonable benchmark forecast method is the seasonal naive method, where forecasts are set to be equal to the last observed value from the same quarter. Alternative models for this series are ETS and ARIMA models. All these can be included in a single call to the `model()` function like this.\n\n\n::: {.cell hash='index_cache/html/snowy-models_516ca492d03e27fe45a5c9c85173b9b1'}\n\n```{.r .cell-code}\nfit <- snowy %>%\n  model(\n    snaive = SNAIVE(Trips ~ lag(\"year\")),\n    ets = ETS(Trips),\n    arima = ARIMA(Trips)\n  )\nfit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A mable: 1 x 6\n# Key:     Region, State, Purpose [1]\n  Region       State Purpose   snaive          ets                    arima\n  <chr>        <chr> <chr>    <model>      <model>                  <model>\n1 Snowy Mount… NSW   Holiday <SNAIVE> <ETS(M,N,A)> <ARIMA(1,0,0)(0,1,2)[4]>\n```\n:::\n:::\n\n\nThe returned object is called a \"mable\" or model table, where each cell corresponds to a fitted model. Because we have only fitted models to one time series, this mable has only one row.\n\nTo forecast all models, we pass the object to the `forecast` function.\n\n\n::: {.cell hash='index_cache/html/snowy-fc_39d8570b4c05f1e828ce4aacc6a8f70e'}\n\n```{.r .cell-code}\nfc <- fit %>%\n  forecast(h = 12)\nfc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A fable: 36 x 7 [1Q]\n# Key:     Region, State, Purpose, .model [3]\n   Region          State Purpose .model Quarter        Trips .mean\n   <chr>           <chr> <chr>   <chr>    <qtr>       <dist> <dbl>\n 1 Snowy Mountains NSW   Holiday snaive 2018 Q1  N(119, 666) 119. \n 2 Snowy Mountains NSW   Holiday snaive 2018 Q2  N(124, 666) 124. \n 3 Snowy Mountains NSW   Holiday snaive 2018 Q3  N(378, 666) 378. \n 4 Snowy Mountains NSW   Holiday snaive 2018 Q4   N(85, 666)  84.7\n 5 Snowy Mountains NSW   Holiday snaive 2019 Q1 N(119, 1331) 119. \n 6 Snowy Mountains NSW   Holiday snaive 2019 Q2 N(124, 1331) 124. \n 7 Snowy Mountains NSW   Holiday snaive 2019 Q3 N(378, 1331) 378. \n 8 Snowy Mountains NSW   Holiday snaive 2019 Q4  N(85, 1331)  84.7\n 9 Snowy Mountains NSW   Holiday snaive 2020 Q1 N(119, 1997) 119. \n10 Snowy Mountains NSW   Holiday snaive 2020 Q2 N(124, 1997) 124. \n# … with 26 more rows\n```\n:::\n:::\n\n\nThe return object is a \"fable\" or forecast table with the following characteristics:\n\n  * the `.model` column becomes an additional key;\n  * the `.distribution` column contains the estimated probability distribution of the response variable in future time periods;\n  * the `Trips` column contains the point forecasts equal to the mean of the probability distribution.\n\nThe `autoplot()` function will produce a plot of all forecasts. By default, `level=c(80,95)` so 80% and 95% prediction intervals are shown. But to avoid clutter, we will set `level=NULL` to show no prediction intervals.\n\n\n::: {.cell hash='index_cache/html/snowy-fc-plot_a96232f8b4e28263c45a5e6ed0473b5d'}\n\n```{.r .cell-code}\nfc %>%\n  autoplot(snowy, level = NULL) +\n  ggtitle(\"Forecasts for Snowy Mountains holidays\") +\n  xlab(\"Year\") +\n  guides(colour = guide_legend(title = \"Forecast\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/snowy-fc-plot-1.png){width=672}\n:::\n:::\n\n\nIf you want to compute the prediction intervals, the `hilo()` function can be used:\n\n\n::: {.cell hash='index_cache/html/hilo_99510280d185553078a69073a87307eb'}\n\n```{.r .cell-code}\nhilo(fc, level = 95)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 36 x 8 [1Q]\n# Key:       Region, State, Purpose, .model [3]\n   Region    State Purpose .model Quarter        Trips .mean          `95%`\n   <chr>     <chr> <chr>   <chr>    <qtr>       <dist> <dbl>         <hilo>\n 1 Snowy Mo… NSW   Holiday snaive 2018 Q1  N(119, 666) 119.  [ 68.5, 170]95\n 2 Snowy Mo… NSW   Holiday snaive 2018 Q2  N(124, 666) 124.  [ 73.9, 175]95\n 3 Snowy Mo… NSW   Holiday snaive 2018 Q3  N(378, 666) 378.  [327.6, 429]95\n 4 Snowy Mo… NSW   Holiday snaive 2018 Q4   N(85, 666)  84.7 [ 34.1, 135]95\n 5 Snowy Mo… NSW   Holiday snaive 2019 Q1 N(119, 1331) 119.  [ 47.5, 191]95\n 6 Snowy Mo… NSW   Holiday snaive 2019 Q2 N(124, 1331) 124.  [ 53.0, 196]95\n 7 Snowy Mo… NSW   Holiday snaive 2019 Q3 N(378, 1331) 378.  [306.6, 450]95\n 8 Snowy Mo… NSW   Holiday snaive 2019 Q4  N(85, 1331)  84.7 [ 13.1, 156]95\n 9 Snowy Mo… NSW   Holiday snaive 2020 Q1 N(119, 1997) 119.  [ 31.4, 207]95\n10 Snowy Mo… NSW   Holiday snaive 2020 Q2 N(124, 1997) 124.  [ 36.9, 212]95\n# … with 26 more rows\n```\n:::\n:::\n\n\n## Forecasting many series\n\nTo scale this up to include all series in the `tourism` data set requires no more work --- we use exactly the same code.\n\n\n::: {.cell hash='index_cache/html/scaleup2_9f18df39c0d0c5eaabe5bcd97b4439a3'}\n\n```{.r .cell-code}\nfit <- tourism %>%\n  model(\n    snaive = SNAIVE(Trips ~ lag(\"year\")),\n    ets = ETS(Trips),\n    arima = ARIMA(Trips)\n  )\nfit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A mable: 304 x 6\n# Key:     Region, State, Purpose [304]\n   Region         State Purpose    snaive          ets\n   <chr>          <chr> <chr>     <model>      <model>\n 1 Adelaide       SA    Business <SNAIVE> <ETS(M,N,M)>\n 2 Adelaide       SA    Holiday  <SNAIVE> <ETS(A,N,A)>\n 3 Adelaide       SA    Other    <SNAIVE> <ETS(M,A,N)>\n 4 Adelaide       SA    Visiting <SNAIVE> <ETS(A,N,A)>\n 5 Adelaide Hills SA    Business <SNAIVE> <ETS(A,N,N)>\n 6 Adelaide Hills SA    Holiday  <SNAIVE> <ETS(A,A,N)>\n 7 Adelaide Hills SA    Other    <SNAIVE> <ETS(A,N,N)>\n 8 Adelaide Hills SA    Visiting <SNAIVE> <ETS(M,A,M)>\n 9 Alice Springs  NT    Business <SNAIVE> <ETS(M,N,M)>\n10 Alice Springs  NT    Holiday  <SNAIVE> <ETS(M,N,A)>\n# … with 294 more rows, and 1 more variable: arima <model>\n```\n:::\n:::\n\n\nNow the mable includes models for every combination of keys in the `tourism` data set.\n\nWe can extract information about some specific model using the `filter`, `select` and `report` functions.\n\n\n::: {.cell hash='index_cache/html/ausholidays-report_98389b27a6432e05d51dab8d60629438'}\n\n```{.r .cell-code}\nfit %>%\n  filter(Region == \"Snowy Mountains\", Purpose == \"Holiday\") %>%\n  select(arima) %>%\n  report()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSeries: Trips \nModel: ARIMA(1,0,0)(0,1,2)[4] \n\nCoefficients:\n        ar1    sma1    sma2\n      0.216  -0.371  -0.190\ns.e.  0.116   0.128   0.116\n\nsigma^2 estimated as 592.9:  log likelihood=-350\nAIC=707   AICc=708   BIC=716\n```\n:::\n:::\n\n\nWhen the mable is passed to the `forecast()` function, forecasts are computed for every model and every key combination.\n\n\n::: {.cell hash='index_cache/html/scaleup3_0b11b200375a2e47353f46ef954b1f82'}\n\n```{.r .cell-code}\nfc <- fit %>%\n  forecast(h = \"3 years\")\nfc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A fable: 10,944 x 7 [1Q]\n# Key:     Region, State, Purpose, .model [912]\n   Region   State Purpose  .model Quarter        Trips .mean\n   <chr>    <chr> <chr>    <chr>    <qtr>       <dist> <dbl>\n 1 Adelaide SA    Business snaive 2018 Q1 N(129, 2018)  129.\n 2 Adelaide SA    Business snaive 2018 Q2 N(174, 2018)  174.\n 3 Adelaide SA    Business snaive 2018 Q3 N(185, 2018)  185.\n 4 Adelaide SA    Business snaive 2018 Q4 N(197, 2018)  197.\n 5 Adelaide SA    Business snaive 2019 Q1 N(129, 4036)  129.\n 6 Adelaide SA    Business snaive 2019 Q2 N(174, 4036)  174.\n 7 Adelaide SA    Business snaive 2019 Q3 N(185, 4036)  185.\n 8 Adelaide SA    Business snaive 2019 Q4 N(197, 4036)  197.\n 9 Adelaide SA    Business snaive 2020 Q1 N(129, 6054)  129.\n10 Adelaide SA    Business snaive 2020 Q2 N(174, 6054)  174.\n# … with 10,934 more rows\n```\n:::\n:::\n\n\nNote the use of natural language to specify the forecast horizon. The `forecast()` function is able to interpret many different time specifications. For quarterly data, `h = \"3 years\"` is equivalent to setting `h = 12`.\n\nPlots of individual forecasts can also be produced, although filtering is helpful to avoid plotting too many series at once.\n\n\n::: {.cell hash='index_cache/html/ausholidays-forecast-plot_6d37bb49dc8c246f711411544229f012'}\n\n```{.r .cell-code}\nfc %>%\n  filter(Region == \"Snowy Mountains\") %>%\n  autoplot(tourism, level = NULL) +\n  xlab(\"Year\") + ylab(\"Overnight trips (thousands)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ausholidays-forecast-plot-1.png){width=672}\n:::\n:::\n\n\n## Forecast accuracy calculations\n\nTo compare the forecast accuracy of these models, we will create a training data set containing all data up to 2014. We will then forecast the remaining years in the data set and compare the results with the actual values.\n\n\n::: {.cell hash='index_cache/html/trainall_2790be987e67b590de49ea80c599250a'}\n\n```{.r .cell-code}\ntrain <- tourism %>%\n  filter(year(Quarter) <= 2014)\nfit <- train %>%\n  model(\n    ets = ETS(Trips),\n    arima = ARIMA(Trips),\n    snaive = SNAIVE(Trips)\n  ) %>%\n  mutate(mixed = (ets + arima + snaive) / 3)\n```\n:::\n\n\nHere we have introduced an ensemble forecast (`mixed`) which is a simple average of the three fitted models. Note that `forecast()` will produce distributional forecasts from the ensemble as well, taking into account the correlations between the forecast errors of the component models.\n\n\n::: {.cell hash='index_cache/html/trainfc_1c8879912ea09c06deb319834a457e36'}\n\n```{.r .cell-code}\nfc <- fit %>% forecast(h = \"3 years\")\n```\n:::\n\n::: {.cell hash='index_cache/html/snowytrain_d17c77e44772d60ca572be7723312d26'}\n\n```{.r .cell-code}\nfc %>%\n  filter(Region == \"Snowy Mountains\") %>%\n  autoplot(tourism, level = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/snowytrain-1.png){width=672}\n:::\n:::\n\n\nNow to check the accuracy, we use the `accuracy()` function. By default it computes several point forecasting accuracy measures such as MAE, RMSE, MAPE and MASE for every key combination.\n\n\n::: {.cell hash='index_cache/html/snowy-test-accuracy_441ddae145232e31c8f41c96429cb687'}\n\n```{.r .cell-code}\naccuracy(fc, tourism)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,216 × 13\n   .model Region State Purpose .type    ME  RMSE   MAE      MPE  MAPE  MASE\n   <chr>  <chr>  <chr> <chr>   <chr> <dbl> <dbl> <dbl>    <dbl> <dbl> <dbl>\n 1 arima  Adela… SA    Busine… Test  22.5  28.5  25.3    11.9    14.0 0.765\n 2 arima  Adela… SA    Holiday Test  21.9  34.8  28.0     9.93   14.8 1.31 \n 3 arima  Adela… SA    Other   Test   4.71 17.5  14.6     0.529  20.2 1.11 \n 4 arima  Adela… SA    Visiti… Test  32.8  37.1  32.8    13.7    13.7 1.05 \n 5 arima  Adela… SA    Busine… Test   1.31  5.58  3.57 -Inf     Inf   1.09 \n 6 arima  Adela… SA    Holiday Test   6.46  7.43  6.46   37.4    37.4 1.14 \n 7 arima  Adela… SA    Other   Test   1.35  2.79  1.93  -31.0    99.4 1.71 \n 8 arima  Adela… SA    Visiti… Test   8.37 12.6  10.4    -3.98   72.3 1.35 \n 9 arima  Alice… NT    Busine… Test   9.85 12.2  10.7    34.4    44.3 1.74 \n10 arima  Alice… NT    Holiday Test   4.80 11.3   9.30    4.46   35.2 1.00 \n# … with 1,206 more rows, and 2 more variables: RMSSE <dbl>, ACF1 <dbl>\n```\n:::\n:::\n\n\nBut because we have generated distributional forecasts, it is also interesting to look at the accuracy using CRPS (Continuous Rank Probability Scores) and Winkler Scores (for 95% prediction intervals).\n\n\n::: {.cell hash='index_cache/html/snowy-test-accuracy1_a205e6af574b0554dfb2a39ec606c342'}\n\n```{.r .cell-code}\nfc_accuracy <- accuracy(fc, tourism,\n  measures = list(\n    point_accuracy_measures,\n    interval_accuracy_measures,\n    distribution_accuracy_measures\n  )\n)\n```\n:::\n\n::: {.cell hash='index_cache/html/snowy-test-accuracy2_94056ebc4ea1650f73e2b4ea2ae2ca54'}\n\n```{.r .cell-code}\nfc_accuracy %>%\n  group_by(.model) %>%\n  summarise(\n    RMSE = mean(RMSE),\n    MAE = mean(MAE),\n    MASE = mean(MASE),\n    Winkler = mean(winkler),\n    CRPS = mean(CRPS)\n  ) %>%\n  arrange(RMSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n  .model  RMSE   MAE  MASE Winkler  CRPS\n  <chr>  <dbl> <dbl> <dbl>   <dbl> <dbl>\n1 mixed   19.8  16.0 0.997    104.  11.4\n2 ets     20.2  16.4 1.00     128.  11.9\n3 snaive  21.5  17.3 1.17     121.  12.8\n4 arima   21.9  17.8 1.06     141.  13.0\n```\n:::\n:::\n\n\nIn this case, the `mixed` model is doing best on all accuracy measures.\n\n## Moving from **forecast** to **fable**\n\nMany readers will be familiar with the **forecast** package and will wonder about the differences between **forecast** and **fable**. Here are some of the main differences.\n\n * **fable** is designed for `tsibble` objects, **forecast** is designed for `ts` objects.\n * **fable** handles many time series at a time, **forecast** handles one time series at a time.\n * **fable** can fit multiple models at once, **forecast** fits one model at a time.\n * **forecast** produces point forecasts and prediction intervals. **fable** produces point forecasts and distribution forecasts. In **fable**, you can get prediction intervals from the forecast object using `hilo()` and in plots using `autoplot()`.\n * **fable** handles ensemble forecasting easily whereas **forecast** has no facilities for ensembles.\n * **fable** has a more consistent interface with every model specified as a formula.\n * Automated modelling in **fable** is obtained by simply not specifying the right hand side of the formula. This was shown in the `ARIMA()` and `ETS()` functions here.\n\nSubsequent posts will explore other features of the **fable** package.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}