{
  "hash": "f18c401c11371c226598e780c53d4438",
  "result": {
    "markdown": "---\ndate: 2012-05-02 07:51:05+00:00\nslug: tscharacteristics\ntitle: Measuring time series characteristics\ncategories:\n- forecasting\n- R\n- statistics\n- time series\n---\n\n::: {.cell}\n\n:::\n\n\nA few years ago, I was working on a project where we measured various characteristics of a time series and used the information to determine what forecasting method to apply or how to cluster the time series into meaningful groups. The two main papers to come out of that project were:\n\n  1. [Wang, Smith and Hyndman (2006) Characteristic-​​based clustering for time series data. _Data Mining and Knowledge Discovery_, **13**(3), 335-364.](/publications/characteristic-based-clustering-for-time-series-data/)\n\n  2. [Wang, Smith-Miles and Hyndman (2009) \"Rule induction for forecasting method selection: meta-​​learning the characteristics of univariate time series\", _Neurocomputing_, **72**, 2581-2594.](/publications/forecast-rules/)\n\nI've since had a lot of requests for the code which one of my coauthors has been helpfully emailing to anyone who asked. But to make it easier, we thought it might be helpful if I post some updated code here. This is not the same as the R code we used in the paper, as I've improved it in several ways (so it will give different results). If you just want the code, skip to the bottom of the post.\n\n## Finding the period of the data\n\nUsually in time series work, we know the period of the data (if the observations are monthly, the period is 12, for example). But in this project, some of our data was of unknown period and we wanted a method to automatically determine the appropriate period. The method we used was based on local peaks and troughs in the ACF. But I've since devised a better approach ([prompted on crossvalidated.com](http://stats.stackexchange.com/a/1214/159)) using an estimate of the spectral density:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_acee353bd801b4563e55b6d6c2c5cb7d'}\n\n```{.r .cell-code}\nfindfrequency <- function(x)\n{\n  n <- length(x)\n  x <- as.ts(x)\n  # Remove trend from data\n  x <- residuals(tslm(x ~ trend))\n  # Compute spectrum by fitting ar model to largest section of x\n  n.freq <- 500\n  spec <- spec.ar(c(na.contiguous(x)), plot=FALSE, n.freq=n.freq)\n  if(max(spec[[\"spec\"]])>10) # Arbitrary threshold chosen by trial and error.\n  {\n    period <- floor(1/spec[[\"freq\"]][which.max(spec[[\"spec\"]])] + 0.5)\n    if(period==Inf) # Find next local maximum\n    {\n      j <- which(diff(spec[[\"spec\"]])>0)\n      if(length(j)>0)\n      {\n        nextmax <- j[1] + which.max(spec[[\"spec\"]][(j[1]+1):n.freq])\n        if(nextmax < length(spec[[\"freq\"]]))\n          period <- floor(1/spec[[\"freq\"]][nextmax] + 0.5)\n        else\n          period <- 1L\n      }\n      else\n        period <- 1L\n    }\n  }\n  else\n    period <- 1L\n\n  return(as.integer(period))\n}\n```\n:::\n\n\nThe function is called `findfrequency` because time series people often call the period of seasonality the \"frequency\" (which is of course highly confusing).\n\n[Update: This function is now part of the forecast package.]\n\n## Decomposing the data into trend and seasonal components\n\nWe needed a measure of the strength of trend and the strength of seasonality, and to do this we decomposed the data into trend, seasonal and error terms.\n\nBecause not all data could be decomposed additively, we first needed to apply an automated Box-Cox transformation. We tried a range of Box-Cox parameters on a grid, and selected the one which gave the most normal errors. That worked ok, but I've since found some papers that provide quite good automated Box-Cox algorithms that I've implemented in the forecast package. So this code uses Guerrero's (1993) method instead.\n\nFor seasonal time series, we decomposed the transformed data using an stl decomposition with periodic seasonality.\n\nFor non-seasonal time series, we estimated the trend of the transformed data using penalized regression splines via the [mgcv package](http://cran.r-project.org/package=mgcv).\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_8135b78cebe38aae000d7697fdc03163'}\n\n```{.r .cell-code}\ndecomp <- function(x,transform=TRUE)\n{\n  require(forecast)\n  # Transform series\n  if(transform & min(x,na.rm=TRUE) >= 0)\n  {\n    lambda <- BoxCox.lambda(na.contiguous(x))\n    x <- BoxCox(x,lambda)\n  }\n  else\n  {\n    lambda <- NULL\n    transform <- FALSE\n  }\n  # Seasonal data\n  if(frequency(x)>1)\n  {\n    x.stl <- stl(x,s.window=\"periodic\",na.action=na.contiguous)\n    trend <- x.stl[[\"time.series\"]][,2]\n    season <- x.stl[[\"time.series\"]][,1]\n    remainder <- x - trend - season\n  }\n  else #Nonseasonal data\n  {\n    require(mgcv)\n    tt <- 1:length(x)\n    trend <- rep(NA,length(x))\n    trend[!is.na(x)] <- fitted(gam(x ~ s(tt)))\n    season <- NULL\n    remainder <- x - trend\n  }\n  return(list(x=x,trend=trend,season=season,remainder=remainder,\n    transform=transform,lambda=lambda))\n}\n```\n:::\n\n\n## Putting everything on a [0,1] scale\n\nWe wanted to measure a range of characteristics such as strength of seasonality, strength of trend, level of nonlinearity, skewness, kurtosis, serial correlatedness, self-similarity, level of chaoticity (is that a word?) and the periodicity of the data. But we wanted all these on the same scale which meant mapping the natural range of each measure onto [0,1]. The following two functions were used to do this.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_32ff3759757433c33a144379a97af2d2'}\n\n```{.r .cell-code}\n# f1 maps [0,infinity) to [0,1]\nf1 <- function(x,a,b)\n{\n  eax <- exp(a*x)\n  if (eax == Inf)\n    f1eax <- 1\n  else\n    f1eax <- (eax-1)/(eax+b)\n  return(f1eax)\n}\n\n# f2 maps [0,1] onto [0,1]\nf2 <- function(x,a,b)\n{\n  eax <- exp(a*x)\n  ea <- exp(a)\n  return((eax-1)/(eax+b)*(ea+b)/(ea-1))\n}\n```\n:::\n\n\nThe values of *a* and *b* in each function were chosen so the measure had a 90th percentile of 0.10 when the data were iid standard normal, and a value of 0.9 using a well-known benchmark time series.\n\n## Calculating the measures\n\nNow we are ready to calculate the measures on the original data, as well as on the adjusted data (after removing trend and seasonality).\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_e2ca36db444eb03a503ddb37e558ccc2'}\n\n```{.r .cell-code}\nmeasures <- function(x)\n{\n  require(forecast)\n\n  N <- length(x)\n  freq <- findfrequency(x)\n  fx <- c(frequency=(exp((freq-1)/50)-1)/(1+exp((freq-1)/50)))\n  x <- ts(x,f=freq)\n\n  # Decomposition\n  decomp.x <- decomp(x)\n\n  # Adjust data\n  if(freq > 1)\n    fits <- decomp.x[[\"trend\"]] + decomp.x[[\"season\"]]\n  else # Nonseasonal data\n    fits <- decomp.x[[\"trend\"]]\n  adj.x <- decomp.x[[\"x\"]] - fits + mean(decomp.x[[\"trend\"]], na.rm=TRUE)\n\n  # Backtransformation of adjusted data\n  if(decomp.x[[\"transform\"]])\n    tadj.x <- InvBoxCox(adj.x,decomp.x[[\"lambda\"]])\n  else\n    tadj.x <- adj.x\n\n  # Trend and seasonal measures\n  v.adj <- var(adj.x, na.rm=TRUE)\n  if(freq > 1)\n  {\n    detrend <- decomp.x[[\"x\"]] - decomp.x[[\"trend\"]]\n    deseason <- decomp.x[[\"x\"]] - decomp.x[[\"season\"]]\n    trend <- ifelse(var(deseason,na.rm=TRUE) < 1e-10, 0,\n      max(0,min(1,1-v.adj/var(deseason,na.rm=TRUE))))\n    season <- ifelse(var(detrend,na.rm=TRUE) < 1e-10, 0,\n      max(0,min(1,1-v.adj/var(detrend,na.rm=TRUE))))\n  }\n  else #Nonseasonal data\n  {\n    trend <- ifelse(var(decomp.x[[\"x\"]],na.rm=TRUE) < 1e-10, 0,\n      max(0,min(1,1-v.adj/var(decomp.x[[\"x\"]],na.rm=TRUE))))\n    season <- 0\n  }\n\n  m <- c(fx,trend,season)\n\n  # Measures on original data\n  xbar <- mean(x,na.rm=TRUE)\n  s <- sd(x,na.rm=TRUE)\n\n  # Serial correlation\n  Q <- Box.test(x,lag=10)[[\"statistic\"]]/(N*10)\n  fQ <- f2(Q,7.53,0.103)\n\n  # Nonlinearity\n  p <- tseries::terasvirta.test(na.contiguous(x))[[\"statistic\"]]\n  fp <- f1(p,0.069,2.304)\n\n  # Skewness\n  sk <- abs(mean((x-xbar)^3,na.rm=TRUE)/s^3)\n  fs <- f1(sk,1.510,5.993)\n\n  # Kurtosis\n  k <- mean((x-xbar)^4,na.rm=TRUE)/s^4\n  fk <- f1(k,2.273,11567)\n\n  # Hurst=d+0.5 where d is fractional difference.\n  H <- fracdiff::fracdiff(na.contiguous(x),0,0)[[\"d\"]] + 0.5\n\n  # Lyapunov Exponent\n  if(freq > N-10)\n      stop(\"Insufficient data\")\n  Ly <- numeric(N-freq)\n  for(i in 1:(N-freq))\n  {\n    idx <- order(abs(x[i] - x))\n    idx <- idx[idx < (N-freq)]\n    j <- idx[2]\n    Ly[i] <- log(abs((x[i+freq] - x[j+freq])/(x[i]-x[j])))/freq\n    if(is.na(Ly[i]) | Ly[i]==Inf | Ly[i]==-Inf)\n      Ly[i] <- NA\n  }\n  Lyap <- mean(Ly,na.rm=TRUE)\n  fLyap <- exp(Lyap)/(1+exp(Lyap))\n\n  m <- c(m,fQ,fp,fs,fk,H,fLyap)\n\n  # Measures on adjusted data\n  xbar <- mean(tadj.x, na.rm=TRUE)\n  s <- sd(tadj.x, na.rm=TRUE)\n\n  # Serial\n  Q <- Box.test(adj.x,lag=10)[[\"statistic\"]]/(N*10)\n  fQ <- f2(Q,7.53,0.103)\n\n  # Nonlinearity\n  p <- tseries::terasvirta.test(na.contiguous(adj.x))[[\"statistic\"]]\n  fp <- f1(p,0.069,2.304)\n\n  # Skewness\n  sk <- abs(mean((tadj.x-xbar)^3,na.rm=TRUE)/s^3)\n  fs <- f1(sk,1.510,5.993)\n\n  # Kurtosis\n  k <- mean((tadj.x-xbar)^4,na.rm=TRUE)/s^4\n  fk <- f1(k,2.273,11567)\n\n  m <- c(m,fQ,fp,fs,fk)\n  names(m) <- c(\"frequency\", \"trend\",\"seasonal\",\n    \"autocorrelation\",\"non-linear\",\"skewness\",\"kurtosis\",\n    \"Hurst\",\"Lyapunov\",\n    \"dc autocorrelation\",\"dc non-linear\",\"dc skewness\",\"dc kurtosis\")\n\n  return(m)\n}\n```\n:::\n\n\nHere is a quick example applied to Australian monthly gas production:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_bcc6f7fe7b5c4912da97bf4dd207ea84'}\n\n```{.r .cell-code}\nlibrary(forecast)\nmeasures(gas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         frequency              trend           seasonal    autocorrelation \n            0.1096             0.9989             0.9337             0.9985 \n        non-linear           skewness           kurtosis              Hurst \n            0.4947             0.1282             0.0055             0.9996 \n          Lyapunov dc autocorrelation      dc non-linear        dc skewness \n            0.5662             0.1140             0.0538             0.1743 \n       dc kurtosis \n            0.9992 \n```\n:::\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_82f2546a8a86e196f5e64830b3a3d479'}\n\n:::\n\n\nThe function is far from perfect, and it is not hard to find examples where it fails. For example, it doesn't work with multiple seasonality --- try `measure(taylor)` and check the seasonality. Also, I'm not convinced the kurtosis provides anything useful here, or that the skewness measure is done in the best way possible. But it was really a proof of concept, so we will leave it to others to revise and improve the code.\n\nIn our papers, we took the measures obtained using R, and produced self-organizing maps using [Viscovery](http://www.viscovery.net/somine/). There is now a [som package](http://cran.r-project.org/web/packages/som/) in R for that, so it might be possible to integrate that step into R as well. The dendogram was generated in matlab, although that could now also be done in R using the [ggdendro package](http://cran.r-project.org/web/packages/ggdendro/) for example.\n\n\n* * *\n\n**[Download the code in a single file.](/Rfiles/measures2.R)**\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}