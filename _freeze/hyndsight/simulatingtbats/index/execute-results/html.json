{
  "hash": "bc2492aaf96424dbe81c59dc640cda16",
  "result": {
    "markdown": "---\ndate: 2022-02-18\ntitle: \"Simulating from TBATS models\"\ncategories:\n  - time series\n  - R\n  - forecasting\n  - data science\nimage: index_files/figure-html/unnamed-chunk-2-1.png\n---\n\n\n\n\nI've had several requests for an R function to simulate future values from a TBATS model. We will eventually include TBATS in the [`fable` package](https://fable.tidyverts.org), and the facilities will be added there. But in the meantime, if you are using the [`forecast` package](https://pkg.robjhyndman.com/forecast) and want to simulate from a fitted TBATS model, here is how do it.\n\n## Simulating via one-step forecasts\n\nDoing it efficiently would require a more complicated approach, but this is super easy if you are willing to sacrifice some speed. The trick is to realise that a simulation can be handled easily for almost any time series model using residuals and one-step forecasts. Note that a residual is given by\n$e_t = y_t - \\hat{y}_{t|t-1}$ so we can write\n\n$$y_t = \\hat{y}_{t|t-1} + e_t.$$\n\nTherefore, given data to time $T$, we can simulate iteratively using\n$$y_{T+i}^* = \\hat{y}_{T+i|T+i-1} + \\varepsilon_{T+i}, \\qquad i=1,\\dots,h,$$\nwhere $\\varepsilon_{T+i}$ is randomly generated from the error distribution, or bootstrapped by randomly sampling from past residuals. The value of $\\hat{y}_{T+i|T+i-1}$ can be obtained by applying the model to the series $\\\\{y_1,\\dots,y_T,y^*_{T+1},\\dots,y^*_{T+i-1}\\\\}$ (without re-estimating the parameters) and forecasting one-step ahead. This is the same trick we use to get [prediction intervals for neural network models](https://otexts.com/fpp3/nnetar.html#prediction-intervals-5).\n\n## Implementation\n\nBecause `simulate()` is an S3 method in R, we have to make sure the corresponding `simulate.tbats()` function has all the necessary arguments to match other `simulate` functions. It's also good to make it as close as possible to other `simulate` functions in the `forecast` package, to make it easier for users when switching between them. The real work is done in the last few lines.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-1_8ad3cc8768db0d6f45d20dc288fca673'}\n\n```{.r .cell-code}\nsimulate.tbats <- function(object, nsim=length(object$y),\n                           seed = NULL, future=TRUE,\n                           bootstrap=FALSE, innov = NULL, ...) {\n  if (is.null(innov)) {\n    if (!exists(\".Random.seed\", envir = .GlobalEnv)) {\n      runif(1)\n    }\n    if (is.null(seed)) {\n      RNGstate <- .Random.seed\n    }\n    else {\n      R.seed <- .Random.seed\n      set.seed(seed)\n      RNGstate <- structure(seed, kind = as.list(RNGkind()))\n      on.exit(assign(\".Random.seed\", R.seed, envir = .GlobalEnv))\n    }\n  }\n  else {\n    nsim <- length(innov)\n  }\n  if (bootstrap) {\n    res <- residuals(object)\n    res <- na.omit(res - mean(res, na.rm = TRUE))\n    e <- sample(res, nsim, replace = TRUE)\n  }\n  else if (is.null(innov)) {\n    e <- rnorm(nsim, 0, sqrt(object$variance))\n  } else {\n    e <- innov\n  }\n  x <- getResponse(object)\n\n  y <- numeric(nsim)\n  if(future) {\n    dataplusy <- x\n  } else {\n    # Start somewhere in the original series\n    dataplusy <- ts(sample(x, 1), start=-1/frequency(x),\n                    frequency = frequency(x))\n  }\n  fitplus <- object\n  for(i in seq_along(y)) {\n    y[i] <- forecast(fitplus, h=1)$mean + e[i]\n    dataplusy <- ts(c(dataplusy, y[i]),\n                    start=start(dataplusy), frequency=frequency(dataplusy))\n    fitplus <- tbats(dataplusy, model=fitplus)\n  }\n  return(tail(dataplusy, nsim))\n}\n```\n:::\n\n\nI've [added this to the `forecast` package](https://github.com/robjhyndman/forecast/commit/309f4d9a16b9a04e34b23219d097b0388e97c04a) for the next version.\n\nSomething similar could be written for any other forecasting function that doesn't already have a `simulate` method. Just swap the `tbats` call to the relevant modelling function.\n\n## Example\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_d354f1ef93cf1ccc73f90a1736f18583'}\n\n```{.r .cell-code}\nlibrary(forecast)\nlibrary(ggplot2)\n\nfit <- tbats(USAccDeaths)\np <- USAccDeaths %>% autoplot() +\n  labs(x = \"Year\", y = \"US Accidental Deaths\",\n       title = \"TBATS simulations\")\nfor (i in seq(9)) {\n  p <- p + autolayer(simulate(fit, nsim = 36), series = paste(\"Sim\", i))\n}\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}